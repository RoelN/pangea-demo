// Shim for "man" template tag

(function(scope) {
    scope.man = function man(argv) {
        const term = argv[0];
        let data = scope[term].manPage;
        if (data) {
            if (typeof data === "string") console.log(data);
            else console.log(data.text, ...data.styles);
        }
    };
})(window);

// data containers

const text = [];
const styles = [];

// manpage writing function

const add = (t, style=``) => {
    text.push(t);
    styles.push(`${style};display:block`);
};

// common styles

const heading = `font-size: 1.5em; padding: 10px 0;`;
const dt = `font-weight: bold; margin-left: 1em;`;
const dd = `margin-left: 2em;`;
const code = `font-family: monospace; background: #FFE; width: 100%;`;

// The actual manpage data

add(`Usage`, heading);
add(`let myFont = new Font(name, options);
myFont.onerror = evt => ...
myFont.onload = evt => ...
myFont.onunload = evt => ...
font.src = urlString;`, code);

add(`Constructor options:`, heading);
add(`name`, dt);
add(`The name used as font-family CSS property for this font.`, dd);
add(`options`, dt);
add(`An optional key/value object for additional CSS properties. See https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face for which properties you can specify.`, dd);

add(`load events:`, heading);
add(`onerror`, dt);
add(`...`, dd);
add(`onload`, dt);
add(`...`, dd);
add(`onunload`, dt);
add(`...`, dd);

add(`Details:`, heading);
add(`This can only get more delicious...`);

add(`For additional information, please visit https://github.com/Pomax/Font.js`);

// Assemble and return

const manPage = { text:`%c${text.join(`%c`)}`, styles };

/**
 * Simple event object so people can write the
 * same code they would for anything else.
 */
class Event {
    constructor(type, detail={}, msg) {
        this.type = type;
        this.detail = detail;
        this.msg = msg;
        Object.defineProperty(this, `__mayPropagate`, { enumerable: false, writable: true });
        this.__mayPropagate = true;
    }
    preventDefault() { /* doesnothing */ }
    stopPropagation() { this.__mayPropagate =false; }
    valueOf() { return this; }
    toString() { return this.msg ? `[${this.type} event]: ${this.msg}` : `[${this.type} event]`; }
}


/**
 * Simple event manager so people can write the
 * same code they would for anything else.
 */
class EventManager {
    constructor() {
        this.listeners = {};
    }
    addEventListener(type, listener, useCapture) {
        let bin = this.listeners[type] || [];
        if (useCapture) bin.unshift(listener); else bin.push(listener);
        this.listeners[type] = bin;
    }
    removeEventListener(type, listener) {
        let bin = this.listeners[type] || [];
        let pos = bin.findIndex(e => e===listener);
        if (pos > -1) {
            bin.splice(pos, 1);
            this.listeners[type] = bin;
        }
    }
    dispatch(event) {
        let bin = this.listeners[event.type];
        if (bin) {
            for(let l=0, e=bin.length; l<e; l++) {
                if (!event.__mayPropagate) break;
                bin[l](event);
            }
        }
    }
}

const startDate = (new Date(`1904-01-01T00:00:00+0000`)).getTime();

/**
 * Convert an array of uint8 char into a proper string.
 *
 * @param {uint8[]} data
 */
function asText(data) {
    return Array.from(data).map(v => String.fromCharCode(v)).join(``);
}

/**
 * A data parser for table data, with auto-advancing pointer.
 */
class Parser {
    constructor(dict, dataview, name) {
        this.name = (name || dict.tag || ``).trim();
        this.length = dict.length;
        this.start = dict.offset;
        this.offset = 0;
        this.data = dataview;

        [   `getInt8`,
            `getUint8`,
            `getInt16`,
            `getUint16`,
            `getInt32`,
            `getUint32`,
            `getBigInt64`,
            `getBigUint64`
        ].forEach(name => {
            let fn = name.replace(/get(Big)?/,'').toLowerCase();
            let increment = parseInt(name.replace(/[^\d]/g,'')) / 8;
            Object.defineProperty(this, fn, {
                get: () => this.getValue(name, increment)
            });
        });
    }

    get currentPosition() {
        return this.start + this.offset;
    }

    set currentPosition(position) {
        this.start = position;
        this.offset = 0;
    }

    getValue(type, increment) {
        let pos = this.start + this.offset;
        this.offset += increment;
        try {
            return this.data[type](pos);
        } catch (e) {
            console.error(`parser`, type, increment, this);
            console.error(`parser`, this.start, this.offset);
            throw e;
        }
    }

    flags(n) {
        if (n === 8 || n === 16 || n === 32 || n === 64) {
            return this[`uint${n}`].toString(2).padStart(n,0).split(``).map(v => v==="1");
        }
        console.error(`Error parsing flags: flag types can only be 1, 2, 4, or 8 bytes long`);
        console.trace();
    }

    get tag() {
        const t = this.uint32;
        return asText([t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255]);
    }

    get fixed() {
        let major = this.uint16;
        let minor = Math.round(1000 * this.uint16/65356);
        return major + minor/1000;
    }

    get legacyFixed() {
        // Only used in the `maxp`, `post`, and `vhea` tables.
        let major = this.uint16;
        let minor = (this.uint16).toString(16).padStart(4,0);
        return parseFloat(`${major}.${minor}`);
    }

    get uint24() {
        // Why does DataView not have a 24 bit value getters?
        return (this.uint8 << 16) + (this.uint8 << 8) + (this.uint8);
    }

    get uint128() {
        // I have no idea why the variable uint128 was chosen over a
        // fixed-width uint32, but it was, and so we need to decode it.
        let value = 0;
        for (let i=0; i<5; i++) {
            let byte = this.uint8;
            value = (value * 128) + (byte & 127);
            if (byte < 128) break;
        }
        return value;
    }

    get longdatetime() {
        return new Date(startDate + 1000 * parseInt(this.int64.toString()));
    }

    // alias datatypes

    get fword() { return this.int16; }
    get ufword() { return this.uint16; }
    get offset16() { return this.uint16; }
    get offset32() { return this.uint32; }

    // "that weird datatype"
    get F2DOT14() {
        const bits = p.uint16;
        const integer = [0,1,-2,-1][bits >> 14];
        const fraction = bits & 0x3fff;
        return integer + (fraction / 16384);
    }

    verifyLength() {
        if (this.offset != this.length) {
            console.error(`unexpected parsed table size (${this.offset}) for "${this.name}" (expected ${this.length})`);
        }
    }

    /**
     * Read an entire data block.
     */
    readBytes(n=0, offset=0, bits=8, signed=false) {
        n = n || this.length;
        if (n === 0) return [];

        if (offset) this.currentPosition = offset;

        const fn = `${signed ? ``:`u`}int${bits}`, slice = [];
        while(n--) slice.push(this[fn]);
        return slice;
    }
}

/**
 * ... docs go here ...
 */
class ParsedData {
    constructor(parser) {
        const pGetter = { enumerable: false, get:() => parser };
        Object.defineProperty(this, `parser`, pGetter);

        const start = parser.currentPosition;
        const startGetter = { enumerable: false, get:() => start };
        Object.defineProperty(this, `start`, startGetter);
    }
}

class SimpleTable extends ParsedData{
    constructor(dict, dataview, name) {
        const { parser, start } = super(new Parser(dict, dataview, name));

        // alias the parser as "p"
        const pGetter = { enumerable: false, get:() => parser };
        Object.defineProperty(this, `p`, pGetter);

        // alias the start offset as "tableStart"
        const startGetter = { enumerable: false, get:() => start };
        Object.defineProperty(this, `tableStart`, startGetter);
    }
}

class Format0 {
    constructor(p) {
        this.format = 0;
        this.length = p.uint16;
        this.language = p.uint16;
        // this isn't worth lazy-loading
        this.glyphIdArray = [...new Array(256)].map(_ => p.uint8);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        return 0 <= charCode && charCode <= 255;
    }
}

/**
 * This is a lazy loader but is not optimised for direct record selection,
 * so code will currently load "An entire array" even if it needs only
 * a single element from that array, and the array elements are fixed width.
 *
 * @param {*} object
 * @param {*} property
 * @param {*} getter
 */
function lazy(object, property, getter) {
    let val;
    Object.defineProperty(object, property, {
        get: () => {
            if (val) return val;
            val = getter();
            return val;
        }
    });
};

class Format2 {
    constructor(p) {
        this.format = 2;
        this.length = p.uint16;
        this.language = p.uint16;
        this.subHeaderKeys = [...new Array(256)].map(_ => p.uint16);

        const subHeaderCount = Math.max(...this.subHeaderKeys);

        const subHeaderOffset = p.currentPosition;
        lazy(this, `subHeaders`, () => {
            p.currentPosition = subHeaderOffset;
            return [...new Array(subHeaderCount)].map(_ => new SubHeader(p));
        });

        const glyphIndexOffset = subHeaderOffset + subHeaderCount * 8;
        lazy(this, `glyphIndexArray`, () => {
            p.currentPosition = glyphIndexOffset;
            return [...new Array(subHeaderCount)].map(_ => p.uint16);
        });
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        const low = charCode && 0xFF;
        const high = charCode && 0xFF00;
        const subHeaderKey = this.subHeaders[high];
        const subheader = this.subHeaders[subHeaderKey];
        const first = subheader.firstCode;
        const last = first + subheader.entryCount;
        return first <= low && low <= last;
    }
}

class SubHeader {
    constructor(p) {
        this.firstCode = p.uint16;
        this.entryCount = p.uint16;
        this.idDelta = p.int16 ;
        this.idRangeOffset = p.uint16;
    }
}

class Format4 {
    constructor(p) {
        this.format = 4;
        this.length = p.uint16;
        this.language = p.uint16;
        this.segCountX2 = p.uint16;
        this.searchRange = p.uint16;
        this.entrySelector = p.uint16;
        this.rangeShift = p.uint16;

        // This cmap subformat basically lazy-loads everything. It would be better to
        // not even lazy load but the code is not ready for selective extraction.

        const endCodeOffset = p.currentPosition;
        lazy(this, `endCode`, () => p.readBytes(this.segCountX2, endCodeOffset, 16));

        const startCodeOffset = endCodeOffset + 2 + this.segCountX2;
        lazy(this, `startCode`, () => p.readBytes(this.segCountX2, startCodeOffset, 16));

        const idDeltaOffset = startCodeOffset +  this.segCountX2;
        lazy(this, `idDelta`, () => p.readBytes(this.segCountX2, idDeltaOffset, 16));

        const idRangeOffset = idDeltaOffset + this.segCountX2;
        lazy(this, `idRangeOffset`, () => p.readBytes(this.segCountX2, idRangeOffset, 16));

        const glyphIdArrayOffset = idRangeOffset + this.segCountX2;
        const glyphIdArrayLength = this.length - (glyphIdArrayOffset - this.tableStart);
        lazy(this, `glyphIdArray`, () => p.readBytes(glyphIdArrayLength, glyphIdArrayOffset, 16));

        // also, while not in the spec, we really want to organise all that data into convenient segments
        lazy(this, `segments`, () => this.buildSegments());
    }

    buildSegments() {
        const build = (_,i) => ({
            start: this.startCode[i],
            end: this.endCode[i],
            idDelta: this.idDelta[i],
            idRangeOffset: this.idRangeOffset[i]
        });
        return  [...new Array(this.segCountX2/2)].map(build);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        const segments = this.segments;
        let i = segments.findIndex(s => s.start > charCode);
        if (i===0) return false;
        if (i===-1) i = segments.length;
        let s = segments[i-1];
        if (s.end < charCode) return false;
        return charCode + s.idDelta;
    }
}

class Format6 {
    constructor(p) {
        this.format = 6;
        this.length = p.uint16;
        this.language = p.uint16;
        this.firstCode = p.uint16;
        this.entryCount = p.uint16;

        const getter = () => [...new Array(this.entryCount)].map(_ => p.uint16);
        lazy(this, `glyphIdArray`, getter);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        if (charCode < this.firstCode) return false;
        if (charCode > this.firstCode + this.entryCount) return false;
        return charCode - this.firstCode;
    }
}

class Format8 {
    constructor(p) {
        this.format = 8;
        p.uint16;
        this.length = p.uint32;
        this.language = p.uint32;
        this.is32 = [...new Array(8192)].map(_ => p.uint8);
        this.numGroups = p.uint32;
        const getter = () => [...new Array(this.numGroups)].map(_ => new SequentialMapGroup(p));
        lazy(this, `groups`, getter);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        const groups = this.groups;
        let i = groups.findIndex(s => s.startcharCode > charCode);
        if (i===0) return false;
        if (i===-1) i = groups.length;
        let g = groups[i-1];
        if (g.endcharCode < charCode) return false;
        return charCode - g.startcharCode + g.startGlyphID;
    }
}

class SequentialMapGroup {
    constructor(p) {
        this.startcharCode = p.uint32;
        this.endcharCode = p.uint32;
        this.startGlyphID = p.uint32;
    }
}

// basically Format 6, but for 32 bit characters
class Format10 {
    constructor(p) {
        this.format = 10;
        p.uint16;
        this.length = p.uint32;
        this.language = p.uint32;
        this.startCharCode = p.uint32;
        this.numChars = p.uint32;
        const getter = () => [...new Array(this.numChars)].map(_ => p.uint16);
        lazy(this, `glyphs`, getter);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        if (charCode < this.startCharCode) return false;
        if (charCode > this.startCharCode + this.numChars) return false;
        return charCode - this.startCharCode;
    }
}

// basically Format 8, but for 32 bit characters
class Format12 {
    constructor(p) {
        this.format = 12;
        p.uint16;
        this.length = p.uint32;
        this.language = p.uint32;
        this.numGroups = p.uint32;
        const getter = () => [...new Array(this.numGroups)].map(_ => new SequentialMapGroup$1(p));
        lazy(this, `groups`, getter);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        const groups = this.groups;
        let i = groups.findIndex(s => s.startcharCode > charCode);
        if (i===0) return false;
        if (i===-1) i = groups.length;
        let g = groups[i-1];
        if (g.endcharCode < charCode) return false;
        return charCode - g.startcharCode + g.startGlyphID;
    }
}

class SequentialMapGroup$1 {
    constructor(p) {
        this.startCharCode = p.uint32;
        this.endCharCode = p.uint32;
        this.startGlyphID = p.uint32;
    }
}

class Format13 {
    constructor(p) {
        this.format = 13;
        p.uint16;
        this.length = p.uint32;
        this.language = p.uint32;
        this.numGroups = p.uint32;
        const getter = [...new Array(this.numGroups)].map(_ => new ConstantMapGroup(p));
        lazy(this, `groups`, getter);
    }

    supports(charCode) {
        if (charCode.charCodeAt) charCode = charCode.charCodeAt(0);
        const groups = this.groups;
        let i = groups.findIndex(s => s.startCharCode > charCode);
        if (i===0) return false;
        if (i===-1) i = groups.length;
        let g = groups[i-1];
        if (g.endcharCode < charCode) return false;
        return g.glyphId;
    }
}

class ConstantMapGroup {
    constructor(p) {
        this.startCharCode = p.uint32;
        this.endCharCode = p.uint32;
        this.glyphID = p.uint32;
    }
}

class Format14 {
    constructor(p) {
        this.subTableStart = p.currentPosition;
        this.format = 14;
        this.length = p.uint32;
        this.numVarSelectorRecords = p.uint32;
        const getter = () => [...new Array(this.numVarSelectorRecords)].map(_ => new VariationSelector(p));
        lazy(this, `varSelectors`, getter);
    }

    supportsVariation(variation) {
        let v = this.varSelector.find(uvs => uvs.varSelector === variation);
        return v ? v : false;
    }
}

class VariationSelector {
    constructor(p) {
        this.varSelector = p.uint24;
        this.defaultUVSOffset = p.offset32;
        this.nonDefaultUVSOffset = p.offset32;
    }
}

// cmap subtables

/**
 * Cmap Subtable factory
 * @param {int} format the subtable format number (see https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-0-byte-encoding-table onward)
 * @param {parser} parser a parser already pointing at the subtable's data location, right after reading the `format` uint16.
 */
function createSubTable(format, parser) {
    if (format === 0) return new Format0(parser);
    if (format === 2) return new Format2(parser);
    if (format === 4) return new Format4(parser);
    if (format === 6) return new Format6(parser);
    if (format === 8) return new Format8(parser);
    if (format === 10) return new Format10(parser);
    if (format === 12) return new Format12(parser);
    if (format === 13) return new Format13(parser);
    if (format === 14) return new Format14(parser);
    return {};
};

/**
 * The OpenType `cmap` main table.
 *
 * Subtables are found in the ./cmap directory
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/cmap for more information
 */
class cmap extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.version = p.uint16;
        this.numTables = p.uint16;
        this.encodingRecords = [...new Array(this.numTables)].map(_ => new EncodingRecord(p));
    }

    get(tableID) {
        let record = this.encodingRecords[tableID];
        if (record) {
            const dict = { offset: this.tableStart + record.offset };
            const p = new Parser(dict, this.parser.data, `Cmap subtable record ${tableID}`);
            const format = p.uint16;
            return createSubTable(format, p);
        }
    }

    supports(char) {
        return this.encodingRecords.some((_,tableID) => {
            const t = this.get(tableID);
            return t.supports && t.supports(char) !== false;
        });
    }

    supportsVariation(variation) {
        return this.encodingRecords.some((_,tableID) => {
            const t = this.get(tableID);
            return t.supportsVariation && t.supportsVariation(variation) !== false;
        });
    }
}

/**
 * ...docs go here...
 */
class EncodingRecord {
    constructor(p) {
        this.platformID = p.uint16;
        this.encodingID = p.uint16;
        this.offset = p.offset32;
    }
}

/**
 * The OpenType `gasp` table.
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/gasp
 */
class gasp extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.version = p.uint16;
        this.numRanges = p.uint16;

        const getter = () => [... new Array(this.numRanges)].map(_ => new GASPRange(p));
        lazy(this, `gaspRanges`, getter);
    }
}

/**
 * GASPRange record
 */
class GASPRange {
    constructor(p) {
        this.rangeMaxPPEM = p.uint16;
        this.rangeGaspBehavior = p.uint16;
    }
}

/**
* The OpenType `head` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/head
*/
class head extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.fontRevision = p.fixed;
        this.checkSumAdjustment = p.uint32;
        this.magicNumber = p.uint32;
        this.flags = p.flags(16);
        this.unitsPerEm = p.uint16;
        this.created = p.longdatetime;
        this.modified = p.longdatetime;
        this.xMin = p.int16;
        this.yMin = p.int16;
        this.xMax = p.int16;
        this.yMax = p.int16;
        this.macStyle = p.flags(16);
        this.lowestRecPPEM = p.uint16;
        this.fontDirectionHint = p.uint16;
        this.indexToLocFormat = p.uint16;
        this.glyphDataFormat = p.uint16;

        p.verifyLength();
    }
}

/**
* The OpenType `hhea` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/hhea
*/
class hhea extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.ascender = p.fword;
        this.descender = p.fword;
        this.lineGap = p.fword;
        this.advanceWidthMax = p.ufword;
        this.minLeftSideBearing = p.fword;
        this.minRightSideBearing = p.fword;
        this.xMaxExtent = p.fword;
        this.caretSlopeRise = p.int16;
        this.caretSlopeRun = p.int16;
        this.caretOffset = p.int16;
        p.int16;
        p.int16;
        p.int16;
        p.int16;
        this.metricDataFormat = p.int16;
        this.numberOfHMetrics = p.uint16;

        p.verifyLength();
    }
}

/**
* The OpenType `hmtx` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx
*/
class hmtx extends SimpleTable {
    constructor(dict, dataview, tables) {
        const { p } =  super(dict, dataview);

        const numberOfHMetrics = tables.hhea.numberOfHMetrics;
        const numGlyphs = tables.maxp.numGlyphs;

        const hMetricGetter = () => [...new Array(numberOfHMetrics)].map(_ => new LongHorMetric(p.uint16, p.int16));
        lazy(this, `hMetrics`, hMetricGetter);

        if (numberOfHMetrics < numGlyphs) {
            const lsbGetter = () => [...new Array(numGlyphs - numberOfHMetrics)].map(_ => p.int16);
            lazy(this, `leftSideBearings`, lsbGetter);
        }
    }
}

class LongHorMetric {
    constructor(w, b) {
        this.advanceWidth = w;
        this.lsb = b;
    }
}

/**
* The OpenType `maxp` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/maxp
*/
class maxp extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.version = p.legacyFixed;
        this.numGlyphs = p.uint16;

        if (this.version === 1) {
            this.maxPoints = p.uint16;
            this.maxContours = p.uint16;
            this.maxCompositePoints = p.uint16;
            this.maxCompositeContours = p.uint16;
            this.maxZones = p.uint16;
            this.maxTwilightPoints = p.uint16;
            this.maxStorage = p.uint16;
            this.maxFunctionDefs = p.uint16;
            this.maxInstructionDefs = p.uint16;
            this.maxStackElements = p.uint16;
            this.maxSizeOfInstructions = p.uint16;
            this.maxComponentElements = p.uint16;
            this.maxComponentDepth = p.uint16;
        }

        p.verifyLength();
    }
}

/**
* The OpenType `name` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/name
*/
class name extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.format = p.uint16;
        this.count = p.uint16;
        this.stringOffset = p.offset16; // relative to start of table

        // name records
        this.nameRecords = [...new Array(this.count)].map((_,i) => new NameRecord(p));

        // lang-tag records, if applicable
        if (this.format === 1) {
            this.langTagCount = p.uint16;
            this.langTagRecords = [...new Array(this.langTagCount)].map(_ => new LangTagRecord(p.uint16, p.offset16));
        }

        // cache these values for use in `.get(nameID)`
        this.stringStart = this.tableStart + this.stringOffset;
    }

    /**
     * Resolve a string by ID
     * @param {uint16} nameID the id used to find the name record to resolve.
     */
    get(nameID) {
        let record = this.nameRecords.find(record => record.nameID === nameID);
        if (record) {
            const dict = { offset: this.stringStart + record.offset };
            const p = new Parser(dict, this.parser.data, `Name record ${nameID}`);
            const bytes = new Uint8Array(p.readBytes(record.length));
            return [...bytes].map(v => String.fromCharCode(v)).join(``);
        }
    }
}

/**
 * ...docs go here...
 */
class LangTagRecord {
    constructor(length, offset) {
        this.length = length;
        this.offset = offset;
    }
}

/**
 * ...docs go here...
 */
class NameRecord {
    constructor(p) {
        this.platformID = p.uint16;
        this.encodingID = p.uint16;
        this.languageID = p.uint16;
        this.nameID = p.uint16;
        this.length = p.uint16;
        this.offset = p.offset16;
    }
}

/**
 * The OpenType `OS/2` table.
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/OS2
 */
class OS2 extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.version = p.uint16;
        this.xAvgCharWidth = p.int16;
        this.usWeightClass = p.uint16;
        this.usWidthClass = p.uint16;
        this.fsType = p.uint16;
        this.ySubscriptXSize = p.int16;
        this.ySubscriptYSize = p.int16;
        this.ySubscriptXOffset = p.int16;
        this.ySubscriptYOffset = p.int16;
        this.ySuperscriptXSize = p.int16;
        this.ySuperscriptYSize = p.int16;
        this.ySuperscriptXOffset = p.int16;
        this.ySuperscriptYOffset = p.int16;
        this.yStrikeoutSize = p.int16;
        this.yStrikeoutPosition = p.int16;
        this.sFamilyClass = p.int16;
        this.panose = [... new Array(10)].map(_ => p.uint8);
        this.ulUnicodeRange1 = p.flags(32);
        this.ulUnicodeRange2 = p.flags(32);
        this.ulUnicodeRange3 = p.flags(32);
        this.ulUnicodeRange4 = p.flags(32);
        this.achVendID = p.tag;
        this.fsSelection = p.uint16;
        this.usFirstCharIndex = p.uint16;
        this.usLastCharIndex = p.uint16;
        this.sTypoAscender = p.int16;
        this.sTypoDescender = p.int16;
        this.sTypoLineGap = p.int16;
        this.usWinAscent = p.uint16;
        this.usWinDescent = p.uint16;

        if (this.version === 0) return p.verifyLength();

        this.ulCodePageRange1 = p.flags(32);
        this.ulCodePageRange2 = p.flags(32);

        if (this.version === 1) return p.verifyLength();

        this.sxHeight = p.int16;
        this.sCapHeight = p.int16;
        this.usDefaultChar = p.uint16;
        this.usBreakChar = p.uint16;
        this.usMaxContext = p.uint16;

        if (this.version <= 4) return p.verifyLength();

        this.usLowerOpticalPointSize = p.uint16;
        this.usUpperOpticalPointSize = p.uint16;

        if (this.version === 5) return p.verifyLength();
    }
}

/**
* The OpenType `post` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/post
*/
class post extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.version = p.legacyFixed;
        this.italicAngle = p.fixed;
        this.underlinePosition = p.fword;
        this.underlineThickness = p.fword;
        this.isFixedPitch = p.uint32;
        this.minMemType42 = p.uint32;
        this.maxMemType42 = p.uint32;
        this.minMemType1 = p.uint32;
        this.maxMemType1 = p.uint32;

        if (this.version === 1 || this.version === 3) return p.verifyLength();

        this.numGlyphs = p.uint16;

        if (this.version === 2) {
            this.glyphNameIndex = [...new Array(this.numGlyphs)].map(_ => p.uint16);
            // And then we get:
            //
            //   names = int8[numberNewGlyphs]
            //   Glyph names with length bytes [variable] (a Pascal string)
            //
            // and the full description is not worth my time trying to figure out right now.
            //
            // TODO: get someone to implement that >_>
        }

        if (this.version === 2.5) {
            this.offset = [...new Array(this.numGlyphs)].map(_ => p.int8);
        }
    }
}

/**
 * The OpenType `BASE` table.
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/BASE
 */
class BASE extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.horizAxisOffset = p.offset16; // from beginning of BASE table
        this.vertAxisOffset = p.offset16;  // from beginning of BASE table

        lazy(this, `horizAxis`, () => new AxisTable({ offset: dict.offset + this.horizAxisOffset}, dataview));
        lazy(this, `vertAxis`, () => new AxisTable({ offset: dict.offset + this.vertAxisOffset}, dataview));

        if (this.majorVersion === 1 && this.minorVersion === 1) {
            this.itemVarStoreOffset = p.offset32; // from beginning of BASE table
            lazy(this, `itemVarStore`, () => new AxisTable({ offset: dict.offset + this.itemVarStoreOffset}, dataview));
        }
    }
}

/**
 * Axis table
 */
class AxisTable extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview, `AxisTable`);

        this.baseTagListOffset = p.offset16;    // from beginning of Axis table
        this.baseScriptListOffset = p.offset16; // from beginning of Axis table

        lazy(this, `baseTagList`, () => new BaseTagListTable({ offset: dict.offset + this.baseTagListOffset}, dataview));
        lazy(this, `baseScriptList`, () => new BaseScriptListTable({ offset: dict.offset + this.baseScriptListOffset}, dataview));
    }
}

class BaseTagListTable extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview, `BaseTagListTable`);
        this.baseTagCount = p.uint16;
        // TODO: make lazy?
        this.baselineTags = [...new Array(this.baseTagCount)].map(_ => p.tag);
    }
}

class BaseScriptListTable extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview, `BaseScriptListTable`);
        this.baseScriptCount = p.uint16;

        const recordStart = p.currentPosition;
        lazy(this, `baseScriptRecords`, () => {
            p.currentPosition = recordStart;
            return [...new Array(this.baseScriptCount)].map(_ => new BaseScriptRecord(this.start, p));
        });
    }
}

class BaseScriptRecord {
    constructor(baseScriptListTableStart, p) {
        this.baseScriptTag = p.tag;
        this.baseScriptOffset = p.offset16; // from beginning of BaseScriptList
        lazy(this,`baseScriptTable`,() => {
            p.currentPosition = baseScriptListTableStart + this.baseScriptOffset;
            return new BaseScriptTable(p);
        });
    }
}

class BaseScriptTable {
    constructor(p) {
        this.start = p.currentPosition;
        this.baseValuesOffset = p.offset16;    // from beginning of BaseScript table
        this.defaultMinMaxOffset = p.offset16; // from beginning of BaseScript table
        this.baseLangSysCount = p.uint16;
        this.baseLangSysRecords = [...new Array(this.baseLangSysCount)].map(_ => new BaseLangSysRecord(this.start, p));

        lazy(this, `baseValues`, () => {
            p.currentPosition = this.start + this.baseValuesOffset;
            return new BaseValuesTable(p);
        });

        lazy(this, `defaultMinMax`, () => {
            p.currentPosition = this.start + this.defaultMinMaxOffset;
            return new MinMaxTable(p);
        });
    }
}

class BaseLangSysRecord {
    constructor(baseScriptTableStart, p) {
        this.baseLangSysTag = p.tag;
        this.minMaxOffset = p.offset16; // from beginning of BaseScript table
        lazy(this, `minMax`, () => {
            p.currentPosition = baseScriptTableStart + this.minMaxOffset;
            return new MinMaxTable(p);
        });
    }
}

class BaseValuesTable {
    constructor(p) {
        this.parser = p;
        this.start = p.currentPosition;

        this.defaultBaselineIndex = p.uint16;
        this.baseCoordCount = p.uint16;
        this.baseCoords = [...new Array(this.baseCoordCount)].map(_ => p.offset16);
    }
    getTable(id) {
        this.parser.currentPosition = this.start + this.baseCoords[id];
        return new BaseCoordTable(this.parser);
    }
}

class MinMaxTable {
    constructor(p) {
        this.minCoord = p.offset16;
        this.maxCoord = p.offset16;
        this.featMinMaxCount = p.uint16;

        const recordStart = p.currentPosition;
        lazy(this, `featMinMaxRecords`, () => {
            p.currentPosition = recordStart;
            return [...new Array(this.featMinMaxCount)].map(_ => new FeatMinMaxRecord(p));
        });
    }
}

class FeatMinMaxRecord {
    constructor(p) {
        this.featureTableTag = p.tag;
        this.minCoord = p.offset16;
        this.maxCoord = p.offset16;
    }
}

class BaseCoordTable {
    constructor(p) {
        this.baseCoordFormat = p.uint16;
        this.coordinate = p.int16;
        if (this.baseCoordFormat === 2) {
            this.referenceGlyph = p.uint16;
            this.baseCoordPoint = p.uint16;
        }
        if (this.baseCoordFormat === 3) {
            this.deviceTable = p.offset16;
        }
    }
}

/**
 * ...
 */
class ScriptList extends  ParsedData {
    constructor(p) {
        super(p);
        this.scriptCount = p.uint16;
        this.scriptRecords = [...new Array(this.scriptCount)].map(_ => new ScriptRecord(p));
    }
}

/**
 * ...
 */
class ScriptRecord {
    constructor(p) {
        this.scriptTag = p.tag;
        this.scriptOffset = p.offset16; // Offset to Script table, from beginning of ScriptList
    }
}

/**
 * ...
 */
class ScriptTable extends ParsedData {
    constructor(p) {
        super(p);
        this.defaultLangSys = p.offset16; // Offset to default LangSys table, from beginning of Script table — may be NULL
        this.langSysCount = p.uint16;
        this.langSysRecords = [...new Array(this.langSysCount)].map(_ => new LangSysRecord(p));
    }
}

/**
 * ...
 */
class LangSysRecord {
    constructor(p) {
        this.langSysTag = p.tag;
        this.langSysOffset = p.offset16; // Offset to LangSys table, from beginning of Script table
    }
}

/**
 * ...
 */
class LangSysTable {
    constructor(p) {
        this.lookupOrder = p.offset16;
        this.requiredFeatureIndex = p.uint16;
        this.featureIndexCount = p.uint16;
        this.featureIndices = [...new Array(this.featureIndexCount)].map(_ => p.uint16);
    }
}

class FeatureList extends ParsedData {
    constructor(p) {
        super(p);
        this.featureCount = p.uint16;
        this.featureRecords = [...new Array(this.featureCount)].map(_ => new FeatureRecord(p));
    }
}

class FeatureRecord {
    constructor(p) {
        this.featureTag = p.tag;
        this.featureOffset = p.offset16; // Offset to Feature table, from beginning of FeatureList
    }
}

class FeatureTable {
    constructor(p) {
        this.featureParams = p.offset16;
        this.lookupIndexCount = p.uint16;
        this.lookupListIndices = [...new Array(this.lookupIndexCount)].map(_ => p.uint16);
    }
}

class LookupList extends ParsedData {
    constructor(p) {
        super(p);
        this.lookupCount = p.uint16;
        this.lookups = [...new Array(this.lookupCount)].map(_ => p.offset16); // Array of offsets to Lookup tables, from beginning of LookupList
    }
}

class LookupTable extends ParsedData {
    constructor(p) {
        super(p);
        this.lookupType = p.uint16;
        this.lookupFlag = p.uint16;
        this.subTableCount = p.uint16;
        this.subtableOffsets = [...new Array(this.subTableCount)].map(_ => p.offset16); // Array of offsets to lookup subtables, from beginning of Lookup table
        this.markFilteringSet = p.uint16;
    }
    get rightToLeft() {
        return this.lookupFlag & 0x0001 === 0x0001;
    }
    get ignoreBaseGlyphs() {
        return this.lookupFlag & 0x0002 === 0x0002;
    }
    get ignoreLigatures() {
        return this.lookupFlag & 0x0004 === 0x0004;
    }
    get ignoreMarks() {
        return this.lookupFlag & 0x0008 === 0x0008;
    }
    get useMarkFilteringSet() {
        return this.lookupFlag & 0x0010 === 0x0010;
    }
    get markAttachmentType() {
        return this.lookupFlag & 0xFF00 === 0xFF00;
    }

    getSubTables() {
        return this.subtableOffsets.map(offset => {
            this.parser.currentPosition = this.start + offset;
            return new CoverageTable(this.parser);
        });
    }
}

class CoverageTable extends ParsedData {
    constructor(p) {
        super(p);

        this.coverageFormat = p.uint16;

        if (this.coverageFormat === 1) {
            this.glyphCount = p.uint16;
            this.glyphArray = [...new Array(this.glyphCount)].map(_ => p.uint16);
        }

        if (this.coverageFormat === 2) {
            this.rangeCount = p.uint16;
            this.rangeRecords = [...new Array(this.rangeCount)].map(_ => new CoverageRangeRecord(p));
        }
    }
}

class CoverageRangeRecord {
    constructor(p) {
        this.startGlyphID = p.uint16;
        this.endGlyphID = p.uint16;
        this.startCoverageIndex = p.uint16;
    }
}

/**
* The table layout used by both GSUB and GPOS
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/GSUB
* See https://docs.microsoft.com/en-us/typography/opentype/spec/GPOS
*/
class CommonLayoutTable extends SimpleTable {
    constructor(name, dict, dataview) {
        const { p, tableStart } = super(name, dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.scriptListOffset = p.offset16;
        this.featureListOffset = p.offset16;
        this.lookupListOffset = p.offset16;

        if (this.majorVersion === 1 && this.minorVersion === 1) {
            this.featureVariationsOffset = p.offset32;
        }

        lazy(this, `scriptList`, () => {
            p.currentPosition = tableStart + this.scriptListOffset;
            return new ScriptList(p);
        });

        lazy(this, `featureList`, () => {
            p.currentPosition = tableStart + this.featureListOffset;
            return new FeatureList(p);
        });

        lazy(this, `lookupList`, () => {
            p.currentPosition = tableStart + this.lookupListOffset;
            return new LookupList(p);
        });

        if (this.featureVariationsOffset) {
            lazy(this, `featureVariations`, () => {
                p.currentPosition = tableStart + this.featureVariationsOffset;
                return new FeatureVariations(p);
            });
        }
    }

    // Script functions

    getSupportedScripts() {
        return (this.scriptList).scriptRecords.map(r => r.scriptTag);
    }

    getScriptTable(scriptTag) {
        let record = this.scriptList.scriptRecords.find(r => r.scriptTag === scriptTag);
        this.parser.currentPosition = this.scriptList.start + record.scriptOffset;
        let table = new ScriptTable(this.parser);
        table.scriptTag = scriptTag;
        return table;
    }

    // LangSys functions

    ensureScriptTable(arg) {
        if (typeof arg === "string") {
            return this.getScriptTable(arg);
        }
        return arg;
    }

    getSupportedLangSys(scriptTable) {
        scriptTable = this.ensureScriptTable(scriptTable);
        return scriptTable.langSysRecords.map(l => l.langSysTag);
    }

    getLangSysTable(scriptTable, langSysTag) {
        scriptTable = this.ensureScriptTable(scriptTable);
        let record = (scriptTable.langSysRecords).find(l => l.langSysTag === langSysTag);
        this.parser.currentPosition = scriptTable.start + record.langSysOffset;
        let table = new LangSysTable(this.parser);
        table.langSysTag = langSysTag;
        return table;
    }

    // Feature functions

    getFeatures(langSysTable) {
        return (langSysTable.featureIndices).map(index => this.getFeature(index));
    }

    getFeature(featureIndex) {
        let record = this.featureList.featureRecords[featureIndex];
        this.parser.currentPosition = this.featureList.start + record.featureOffset;
        let table = new FeatureTable(this.parser);
        table.featureTag = record.featureTag;
        return table;
    }

    // Lookup functions

    getLookups(featureTable) {
        return (featureTable.lookupListIndices).map(index => this.getLookup(index));
    }

    getLookup(lookupIndex) {
        let lookupOffset = this.lookupList.lookups[lookupIndex];
        this.parser.currentPosition = this.lookupList.start + lookupOffset;
        return new LookupTable(this.parser);
    }
}

class GSUB extends CommonLayoutTable {
    constructor(dict, dataview) {
        super(dict, dataview);
    }
}

class GPOS extends CommonLayoutTable {
    constructor(dict, dataview) {
        super(dict, dataview);
    }
}

/**
 * The OpenType `SVG` table.
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/SVG
 */
class SVG extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.version = uint16;
        this.offsetToSVGDocumentList = p.offset32; // from the start of the SVG table

        p.currentPosition = this.tableStart + this.offsetToSVGDocumentList;
        this.documentList = new SVGDocumentList(p);
    }
}

/**
 * The SVG document list.
 */
class SVGDocumentList extends ParsedData {
    constructor(p) {
        super(p);
        this.numEntries = p.uint16;
        this.documentRecords = [...new Array(this.numEntries)].map(_ => new SVGDocumentRecord(p));
    }

    /**
     * Get an SVG document by ID
     */
    getDocument(documentID) {
        let record = this.documentRecords[documentID];
        if (!record) return '';

        let offset = this.start + record.svgDocOffset;
        this.parser.currentPosition = offset;
        return this.parser.readBytes(record.svgDocLength);
    }

    /**
     * Get an SVG document given a glyphID
     */
    getDocumentForGlyph(glyphID) {
        let id = this.documentRecords.findIndex(d =>
            d.startGlyphID <= glyphID && glyphID <= d.endGlyphID
        );
        if (id === -1) return '';
        return this.getDocument(id);
    }
}

/**
 * SVG document record, pointing to a specific SVG document encoding a
 * range of glyphs as <g id="glyph{NUM}>...</g> where {NUM} is a number
 * in the range [startGlyphId, endGlyphId].
 */
class SVGDocumentRecord {
    constructor(p) {
        this.startGlyphID = p.uint16;
        this.endGlyphID = p.uint16;
        this.svgDocOffset = p.offset32; // from the beginning of the SVGDocumentList
        this.svgDocLength = p.uint32;
    }
}

/**
 * The OpenType `fvar` table.
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/fvar
 */
class fvar extends SimpleTable {
    constructor(dict, dataview) {
        const { p } = super(dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.axesArrayOffset = p.uint16;
        p.uint16;
        this.axisCount = p.uint16;
        this.axisSize = p.uint16;
        this.instanceCount = p.uint16;
        this.instanceSize = p.uint16;

        const getter = () => [... new Array(this.axisCount)].map(_ =>  new VariationAxisRecord(p));
        lazy(this, `axes`, getter);
    }

    getSupportedAxes() {
        return (this.axes).map(a => a.tag);
    }

    getAxis(name) {
        return (this.axes).find(a => a.tag === name);
    }
}

/**
 * The fvar variation axis record class
 */
class VariationAxisRecord {
    constructor(p) {
        this.tag = p.tag;
        this.minValue = p.fixed;
        this.defaultValue = p.fixed;
        this.maxValue = p.fixed;
        this.flags = p.flags(16);
        this.axisNameID = p.uint16;
    }
}

/**
* The OpenType `CFF` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/CFF
*/
class CFF extends SimpleTable {
    constructor(dict, dataview) {
        const { p } =  super(dict, dataview);
        lazy(this, `data`, () => p.readBytes());
    }
}

/**
* The OpenType `CFF2` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/CFF2
*/
class CFF2 extends SimpleTable {
    constructor(dict, dataview) {
        const { p } =  super(dict, dataview);
        lazy(this, `data`, () => p.readBytes());
    }
}

/**
* The OpenType `VORG` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/VORG
*/
class VORG extends SimpleTable {
    constructor(dict, dataview) {
        const { p } =  super(dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.defaultVertOriginY = p.int16;
        this.numVertOriginYMetrics = p.uint16;

        lazy(this, `vertORiginYMetrics`, () => [...new Array(this.numVertOriginYMetrics)].map(_ => new VertOriginYMetric(p)));
    }
}

class VertOriginYMetric {
    constructor(p) {
        this.glyphIndex = p.uint16;
        this.vertOriginY = p.int16;
    }
}

class BitmapSize {
    constructor(p) {
        this.indexSubTableArrayOffset = p.offset32; // from beginning of CBLC
        this.indexTablesSize = p.uint32;
        this.numberofIndexSubTables = p.uint32;
        this.colorRef = p.uint32;
        this.hori = new SbitLineMetrics(p);
        this.vert = new SbitLineMetrics(p);
        this.startGlyphIndex = p.uint16;
        this.endGlyphIndex = p.uint16;
        this.ppemX = p.uint8;
        this.ppemY = p.uint8;
        this.bitDepth = p.uint8;
        this.flags = p.int8;
    }
}

class BitmapScale {
    constructor(p) {
        this.hori = new SbitLineMetrics(p);
        this.vert = new SbitLineMetrics(p);
        this.ppemX = p.uint8;
        this.ppemY = p.uint8;
        this.substitutePpemX = p.uint8;
        this.substitutePpemY = p.uint8;
    }
}

class SbitLineMetrics {
    constructor(p) {
        this.ascender = p.int8;
        this.descender = p.int8;
        this.widthMax = p.uint8;
        this.caretSlopeNumerator = p.int8;
        this.caretSlopeDenominator = p.int8;
        this.caretOffset = p.int8;
        this.minOriginSB = p.int8;
        this.minAdvanceSB = p.int8;
        this.maxBeforeBL = p.int8;
        this.minAfterBL = p.int8;
        this.pad1 = p.int8;
        this.pad2 = p.int8;
    }
}

class IndexSubHeader {
    constructor(p) {
        this.indexFormat = p.uint16;
        this.imageFormat = p.uint16;
        this.imageDataOffset = p.offset32; // Offset to image data in EBDT table.
    }
}

class BigGlyphMetrics {
    constructor(p) {
        this.height = uint8;
        this.width = uint8;
        this.horiBearingX = int8;
        this.horiBearingY = int8;
        this.horiAdvance = uint8;
        this.vertBearingX = int8;
        this.vertBearingY = int8;
        this.vertAdvance = uint8;
    }
}

class SmallGlyphMetrics {
    constructor(p) {
        this.height = p.uint8;
        this.width = p.uint8;
        this.bearingX = p.int8;
        this.bearingY = p.int8;
        this.advance = p.uint8;
    }
}

class EBDTComponent {
    constructor(p) {
        this.glyphID = p.uint16;
        this.xOffset = p.int8;
        this.yOffset = p.int8;
    }
}

class IndexSubTableArray {
    constructor(p) {
        this.firstGlyphIndex = p.uint16;
        this.lastGlyphIndex = p.uint16;
        this.additionalOffsetToIndexSubtable = p.offset32; // from beginning of EBLC.
    }
}

/**
* The OpenType `EBLC` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/EBLC
*/
class EBLC extends SimpleTable {
    constructor(dict, dataview, name) {
        const { p } =  super(dict, dataview, name);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.numSizes = p.uint32;

        lazy(this, `bitMapSizes`, () => [... new Array(this.numSizes)].map(_ => new BitmapSize(p)));
    }
}

/**
* The OpenType `EBDT` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/EBDT
*/
class EBDT extends SimpleTable {
    constructor(dict, dataview, name) {
        const { p } =  super(dict, dataview, name);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
    }

    // TODO: add a way to get the data out
}

/**
* The OpenType `EBSC` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/EBSC
*/
class EBSC extends SimpleTable {
    constructor(dict, dataview) {
        const { p } =  super(dict, dataview);

        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.numSizes = p.uint32;

        lazy(this, `bitmapScales`, () => [... new Array(this.numSizes)].map(_ => new BitmapScale(p)));
    }
}

/**
* The OpenType `CBLC` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/CBLC
*/
class CBLC extends EBLC {
    constructor(dict, dataview) {
        super(dict, dataview, `CBLC`);
    }
}

/**
* The OpenType `CBDT` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/CBDT
*/
class CBDT extends EBDT {
    constructor(dict, dataview) {
        super(dict, dataview, `CBDT`);
    }

    // TODO: In addition to nine different formats already defined for glyph bitmap data in the EBDT table, there are three more formats
}

/**
* The OpenType `sbix` table.
*
* See https://docs.microsoft.com/en-us/typography/opentype/spec/sbix
*
* Notes:
*   The glyph count is derived from the 'maxp' table. Advance and side-bearing
*   glyph metrics are stored in the 'hmtx' table for horizontal layout, and
*   the 'vmtx' table for vertical layout.
*
*/
class sbix extends SimpleTable {
    constructor(dict, dataview) {
        const { p } =  super(dict, dataview);

        this.version = p.uint16;
        this.flags = p.flags(16);
        this.numStrikes = p.uint32;
        lazy(this, `strikeOffsets`, () => [...new Array(this.numStrikes)].map(_ => p.offset32)); // from the beginning of the 'sbix' table
    }

    // TODO: add a strike accessor
}

class Strike extends ParsedData {
    constructor(p, numGlyphs) {
        this.ppem = p.uint16;
        this.ppi = p.uint16;
        lazy(this, `glyphDataOffsets`, () => [...new Array(numGlyphs + 1)].map(_ => p.offset32)); // from the beginning of the strike data header
    }

    // TODO: add a glyph data accessor
}

class GlyphData {
    constructor(p) {
        this.originOffsetX = p.int16;
        this.originOffsetY = p.int16;
        this.graphicType = p.tag;

        // The actual embedded graphic data has a byte length that is inferred from sequential
        // entries in the strike.glyphDataOffsets array + the fixed size (8 bytes) of the preceding fields.
        const len = 0;
        lazy(this, `data`, () => p.readBytes(len));

        // TODO: make this.data load in the correct data
    }
}

// opentype tables

/**
 * Table factory
 * @param {*} dict an object of the form: { tag: "string", offset: <number>, [length: <number>]}
 * @param {*} dataview a DataView object over an ArrayBuffer of Uint8Array
 */
function createTable(tables, dict, dataview) {
    if (dict.tag === `cmap`) return new cmap(dict, dataview);
    if (dict.tag === `fvar`) return new fvar(dict, dataview);
    if (dict.tag === `gasp`) return new gasp(dict, dataview);
    if (dict.tag === `head`) return new head(dict, dataview);
    if (dict.tag === `hhea`) return new hhea(dict, dataview);
    if (dict.tag === `hmtx`) return new hmtx(dict, dataview, tables);
    if (dict.tag === `maxp`) return new maxp(dict, dataview);
    if (dict.tag === `name`) return new name(dict, dataview);
    if (dict.tag === `OS/2`) return new OS2(dict, dataview);
    if (dict.tag === `post`) return new post(dict, dataview);

    if (dict.tag === `BASE`) return new BASE(dict, dataview);
    if (dict.tag === `GSUB`) return new GSUB(dict, dataview);
    if (dict.tag === `GPOS`) return new GPOS(dict, dataview);

    if (dict.tag === `SVG `) return new SVG(dict, dataview);

    if (dict.tag === `CFF `) return new CFF(dict, dataview);
    if (dict.tag === `CFF2`) return new CFF2(dict, dataview);
    if (dict.tag === `VORG`) return new VORG(dict, dataview);

    if (dict.tag === `EBLC`) return new EBLC(dict, dataview);
    if (dict.tag === `EBDT`) return new EBDT(dict, dataview);
    if (dict.tag === `EBSC`) return new EBSC(dict, dataview);
    if (dict.tag === `CBLC`) return new CBLC(dict, dataview);
    if (dict.tag === `CBDT`) return new CBDT(dict, dataview);
    if (dict.tag === `sbix`) return new sbix(dict, dataview);

    // further code goes here once more table parsers exist
    return {};
};

/**
 * the SFNT header.
 *
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/overview for more information
 */
class SFNT extends SimpleTable {
    constructor(dataview) {
        const { p } = super({ offset: 0, length: 12}, dataview, `sfnt`);

        this.version = p.uint32;
        this.numTables = p.uint16;
        this.searchRange = p.uint16;
        this.entrySelector = p.uint16;
        this.rangeShift = p.uint16;

        p.verifyLength();

        this.directory = [... new Array(this.numTables)].map(_ => new TableRecord(p));

        // add convenience bindings for each table, with lazy loading
        this.tables = {};
        this.directory.forEach(entry => {
            const getter = () => {
                return createTable(this.tables, {
                    tag: entry.tag,
                    offset: entry.offset,
                    length: entry.length
                }, dataview);
            };
            lazy(this.tables, entry.tag.trim(), getter);
        });
    }
}

/**
 * SFNT directory Table Record struct.
 */
class TableRecord {
    constructor(p) {
        this.tag = p.tag;
        this.checksum = p.uint32;
        this.offset = p.uint32;
        this.length = p.uint32;
    }
}

const gzipDecode = (window.pako ? window.pako.inflate : undefined);

/**
 * The WOFF header
 *
 * See https://www.w3.org/TR/WOFF for WOFF information
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/overview for font information
 */
class WOFF extends SimpleTable {
    constructor(dataview) {
        const { p } = super({ offset: 0, length: 44 }, dataview, `woff`);

        this.signature = p.tag;
        this.flavor = p.uint32;
        this.length = p.uint32;
        this.numTables = p.uint16;
        p.uint16;
        this.totalSfntSize = p.uint32;
        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.metaOffset = p.uint32;
        this.metaLength = p.uint32;
        this.metaOrigLength = p.uint32;
        this.privOffset = p.uint32;
        this.privLength = p.uint32;

        p.verifyLength();

        this.directory = [... new Array(this.numTables)].map(_ => new WoffTableDirectoryEntry(p));
        buildWoffLazyLookups(this, dataview);
    }
}

/**
 * ...
 */
class WoffTableDirectoryEntry {
    constructor(p) {
        this.tag = p.tag;
        this.offset = p.uint32;
        this.compLength = p.uint32;
        this.origLength = p.uint32;
        this.origChecksum = p.uint32;
    }
}

/**
 * Build late-evaluating properties for each table in a
 * woff/woff2 font, so that accessing a table via the
 * woff.tables.tableName or woff2.tables.tableName
 * property kicks off a table parse on first access.
 *
 * @param {*} woff the woff or woff2 font object
 * @param {DataView} dataview passed when dealing with woff
 * @param {buffer} decoded passed when dealing with woff2
 */
function buildWoffLazyLookups(woff, dataview) {
    woff.tables = {};
    woff.directory.forEach(entry => {
        lazy(woff.tables, entry.tag.trim(), () => {
                let offset = 0;
                let view = dataview;
                // compressed data?
                if (entry.compLength !== entry.origLength) {
                    const unpacked = gzipDecode(new Uint8Array(dataview.buffer.slice(entry.offset, entry.offset + entry.compLength)));
                    view = new DataView(unpacked.buffer); }
                // uncompressed data.
                else { offset = entry.offset; }
                return createTable(woff.tables, { tag: entry.tag, offset, length: entry.origLength }, view);
        });
    });
}

const brotliDecode = window.unbrotli;


/**
 * The WOFF2 header
 *
 * See https://www.w3.org/TR/WOFF2 for WOFF2 information
 * See https://docs.microsoft.com/en-us/typography/opentype/spec/overview for font information
 */
class WOFF2 extends SimpleTable {
    constructor(dataview) {
        const { p } = super({ offset: 0, length: 48 }, dataview, `woff2`);
        this.signature = p.tag;
        this.flavor = p.uint32;
        this.length = p.uint32;
        this.numTables = p.uint16;
        p.uint16; // why woff2 even has any reserved bytes is a complete mystery. But it does.
        this.totalSfntSize = p.uint32;
        this.totalCompressedSize = p.uint32;
        this.majorVersion = p.uint16;
        this.minorVersion = p.uint16;
        this.metaOffset = p.uint32;
        this.metaLength = p.uint32;
        this.metaOrigLength = p.uint32;
        this.privOffset = p.uint32;
        this.privLength = p.uint32;

        p.verifyLength();

        // parse the dictionary
        this.directory = [... new Array(this.numTables)].map(_ => new Woff2TableDirectoryEntry(p));
        let dictOffset = p.currentPosition;

        // compute table byte offsets in the decompressed data
        this.directory[0].origOffset = 0;
        this.directory.forEach((e,i) => {
            let t = this.directory[i+1];
            if (t) {
                const useTransform = typeof e.transformLength !== "undefined";
                t.origOffset = e.origOffset + (useTransform ? e.transformLength : e.origLength);
            }
        });

        // then decompress the original data and lazy-bind
        let decoded = brotliDecode(new Uint8Array(dataview.buffer.slice(dictOffset)));
        buildWoff2LazyLookups(this, decoded);
    }
}

/**
 * WOFF2 Table Directory Entry
 */
class Woff2TableDirectoryEntry {
    constructor(p) {
        this.flags = p.uint8;

        const tagNumber  = this.tagNumber = this.flags & 63;
        if (tagNumber === 63) {
            this.tag = p.tag;
        } else {
            this.tag = getWOFF2Tag(tagNumber);
        }

        this.origLength = p.uint128;
        const pptVersion = this.pptVersion = this.flags >> 6;
        if (pptVersion !== 0 || ((this.tag === 'glyf' || this.tag === 'loca') && pptVersion !== 3)) {
            this.transformLength = p.uint128;
        }
        this.length = p.offset; // FIXME: we can probably calculat this without asking the parser
    }
}

/**
 * Build late-evaluating properties for each table in a
 * woff/woff2 font, so that accessing a table via the
 * woff.tables.tableName or woff2.tables.tableName
 * property kicks off a table parse on first access.
 *
 * @param {*} woff the woff or woff2 font object
 * @param {DataView} dataview passed when dealing with woff
 * @param {buffer} decoded passed when dealing with woff2
 */
function buildWoff2LazyLookups(woff2, decoded) {
    woff2.tables = {};
    woff2.directory.forEach(entry => {
        lazy(woff2.tables, entry.tag.trim(), () => {
            const useTransform = typeof entry.transformLength !== "undefined";
            const data = decoded.slice(entry.origOffset, entry.origOffset + (useTransform ? entry.transformLength : entry.origLength));
            return createTable(woff2.tables, { tag: entry.tag, offset: 0, length: entry.origLength }, new DataView(data.buffer));
        });
    });
}

/**
 * WOFF2 uses a numbered tag registry, such that only unknown tables require a 4 byte tag
 * in the WOFF directory entry struct. Everything else uses a uint8. Nice and tidy.
 * @param {*} flag
 */
function getWOFF2Tag(flag) {
    return [
        `cmap`,`head`,`hhea`,`hmtx`,`maxp`,`name`,`OS/2`,`post`,`cvt `,`fpgm`,`glyf`,`loca`,`prep`,
        `CFF `,`VORG`,`EBDT`,`EBLC`,`gasp`,`hdmx`,`kern`,`LTSH`,`PCLT`,`VDMX`,`vhea`,`vmtx`,`BASE`,
        `GDEF`,`GPOS`,`GSUB`,`EBSC`,`JSTF`,`MATH`,`CBDT`,`CBLC`,`COLR`,`CPAL`,`SVG `,`sbix`,`acnt`,
        `avar`,`bdat`,`bloc`,`bsln`,`cvar`,`fdsc`,`feat`,`fmtx`,`fvar`,`gvar`,`hsty`,`just`,`lcar`,
        `mort`,`morx`,`opbd`,`prop`,`trak`,`Zapf`,`Silf`,`Glat`,`Gloc`,`Feat`,`Sill`
    ][flag];
}

// basic inmports


/**
 * either return the appropriate CSS format
 * for a specific font URL, or generate an
 * error if someone is trying to use a
 * font that died years ago.
 *
 * @param {*} path
 */
function getFontCSSFormat(path) {
    let pos = path.lastIndexOf(`.`);
    let ext = (path.substring(pos + 1) || ``).toLowerCase();
    let format = {
        ttf: `truetype`,
        otf: `opentype`,
        woff: `woff`,
        woff2: `woff2`
    }[ext];

    if (format) return format;

    let msg = {
        eot: `The .eot format is not supported: it died in January 12, 2016, when Microsoft retired all versions of IE that didn't already support WOFF.`,
        svg: `The .svg format is not supported: SVG fonts (not to be confused with OpenType with embedded SVG) were so bad we took the entire fonts chapter out of the SVG specification again.`,
        fon: `The .fon format is not supported: this is an ancient Windows bitmap font format.`,
        ttc: `Based on the current CSS specification, font collections are not (yet?) supported.`
    }[ext];

    if (!msg) msg = `${url} is not a font.`;

    this.dispatch(new Event(`error`, {}, msg));
}


/**
 * Borderline trivial http response helper function
 *
 * @param {HttpResponse} response
 */
function checkFetchResponseStatus(response) {
    if (!response.ok) {
        throw new Error(`HTTP ${response.status} - ${response.statusText}`);
    }
    return response;
}

/**
 * The Font object, which the WebAPIs are still sorely missing.
 */
class Font extends EventManager {
    constructor(name, options={}) {
        super();
        this.name = name;
        this.options = options;
        this.metrics = false;
    }

    get src() { return this.__src; }

    /**
     * Just like Image and Audio, we kick everything off when
     * our `src` gets assigned.
     *
     * @param {string} url
     */
    set src(url) {
        this.__src = url;
        this.defineFontFace(this.name, url, this.options);
        this.loadFont(url);
    }

    /**
     * This is a blocking operation.
     */
    defineFontFace(name, url, options) {
        let format = getFontCSSFormat(url);
        if (!format) return;
        let style = document.createElement(`style`);
        style.className = `injected by Font.js`;
        let rules = Object.keys(options).map(r => `${r}: ${options[r]};`).join(`\n\t`);
        style.textContent = `
@font-face {
    font-family: "${name}";
    ${rules}
    src: url("${url}") format("${format}");
}`;
        this.styleElement = style;
        document.head.appendChild(style);
    }

    /**
     * This is a non-blocking operation.
     *
     * @param {String} url The URL for the font in question
     */
    async loadFont(url) {
        const type = getFontCSSFormat(url);
        fetch(url)
        .then(response => checkFetchResponseStatus(response) && response.arrayBuffer())
        .then(buffer => this.fromDataBuffer(buffer, type))
        .catch(err => {
            const evt = new Event(`error`, err, `Failed to load font at ${url}`);
            this.dispatch(evt);
            if (this.onerror) this.onerror(evt);
        });
    }

    /**
     * This is a non-blocking operation.
     *
     * @param {Buffer} buffer The binary data associated with this font.
     */
    async fromDataBuffer(buffer, type) {
        this.fontData = new DataView(buffer); // Because we want to enforce Big Endian everywhere
        await this.parseBasicData(type);
        const evt = new Event("load", { font: this });
        this.dispatch(evt);
        if (this.onload) this.onload(evt);
    }

    /**
     * This is a non-blocking operation IF called from an async function
     */
    async parseBasicData(type) {
        if (type === `truetype` || type === `opentype`) {
            this.opentype = new SFNT(this.fontData);
        }
        if (type === `woff`) {
            this.opentype = new WOFF(this.fontData);
        }
        if (type === `woff2`) {
            this.opentype = new WOFF2(this.fontData);
        }
    }

    /**
     * Does this font support the specified character?
     * @param {*} char
     */
    supports(char) {
        return this.opentype.tables.cmap.supports(char) !== false;
    }

    /**
     * Does this font support the specified unicode variation?
     * @param {*} variation
     */
    supportsVariation(variation) {
        return this.opentype.tables.cmap.supportsVariation(variation) !== false;
    }

    /**
     * Effectively, be https://html.spec.whatwg.org/multipage/canvas.html#textmetrics
     * @param {*} text
     * @param {*} size
     */
    measureText(text, size=16) {
        if (this.__unloaded) throw new Error("Cannot measure text: font was unloaded. Please reload before calling measureText()");
        let d = document.createElement('div');
        d.textContent = text;
        d.style.fontFamily = this.name;
        d.style.fontSize = `${size}px`;
        d.style.color = `transparent`;
        d.style.background = `transparent`;
        d.style.top = `0`;
        d.style.left = `0`;
        d.style.position = `absolute`;
        document.body.appendChild(d);
        let bbox = d.getBoundingClientRect();
        document.body.removeChild(d);
        const OS2 = this.opentype.tables["OS/2"];
        bbox.fontSize = size;
        bbox.ascender = OS2.sTypoAscender;
        bbox.descender = OS2.sTypoDescender;
        return bbox;
    }

    /**
     * unload this font from the DOM context, making it no longer available for CSS purposes
     */
    unload() {
        if (this.styleElement.parentNode) {
            this.styleElement.parentNode.removeElement(this.styleElement);
            const evt = new Event("unload", { font: this });
            this.dispatch(evt);
            if (this.onunload) this.onunload(evt);
        }
        this._unloaded = true;
    }

    /**
     * load this font back into the DOM context after being unload()'d earlier.
     */
    unload() {
        if (this.__unloaded) {
            delete this.__unloaded;
            document.head.appendChild(this.styleElement);
            const evt = new Event("load", { font: this });
            this.dispatch(evt);
            if (this.onload) this.onload(evt);
        }
    }
}

Font.manPage = manPage;

window.Font = Font;
